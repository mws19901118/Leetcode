class UnionFind:                                                                                        #Union Find.
    def __init__(self, x):
        self.value = x
        self.parent = self
        
    def union(self, uf):                                                                                #Union with another union find.
        self.parent = self.find()
        uf.find().parent = self.parent
        
    def find(self):                                                                                     #Find and update parent.
        while self.parent != self.parent.parent:
            self.parent = self.parent.parent
        return self.parent
    
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        ufs = []
        for i in range(len(graph)):                                                                     #Create union find for each node.
            ufs.append(UnionFind(i))
        for i in range(len(graph)):                                                                     #Union each adjacent nodes in graph.
            for j in range(i + 1, len(graph)):
                if graph[i][j]:
                    ufs[i].union(ufs[j])
        
        components = collections.defaultdict(set)                                                       #Use a set to find unique components in graph, the nodes inside a component can connect to each other. 
        for uf in ufs:
            components[uf.find().value].add(uf.value)                                                   #The union find of nodes in a component has the same parent.
        
        affected = collections.defaultdict(int)                                                         #Check how many nodes in the component are initially affected by malware.
        for i in initial:
            affected[ufs[i].find().value] += 1
            
        maxValue = 0                                                                                    #Find the max size of an affected component.
        index = -1
        for i in initial:
            s = len(components[ufs[i].find().value])                                                    #Find the size of component which has current node which is initally affected by malware.
            if affected[ufs[i].find().value] == 1 and (s > maxValue or (s == maxValue and i < index)):  #The component must have only 1 node initially affected. Otherwise removing one node from initial list won't have effect since the component will eventually affected by other initially affected node.
                index = i
                maxValue = s
        if index == -1:                                                                                 #If no such node found, return the initially affected node with minimum index.
            return min(initial)
        return index
